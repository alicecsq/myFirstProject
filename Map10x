
eval_UMI
finalfasta = open('/mithril/Data/Nanopore/projects/visium/210309_r2c2_sample6_test/alice_c3poa_outs/c3poa_postprocessing/demuxed/cell56_test.final.fasta', 'a') #if you already have this file it will be APPENDED so if you are doing this more than once be mindful
genedict={}
previous_gene=''
for line in open('/mithril/Data/Nanopore/projects/visium/210309_r2c2_sample6_test/alice_c3poa_outs/c3poa_postprocessing/demuxed/temporary/assignedreads/cell56_test.new.fasta.sorted'):
    line=line.rstrip()
    gene=line.split('\t')[1]
    name=line.split('\t')[0]
    sequence=line.split('\t')[2]
    UMI=sequence[len(sequence)-17::-1][0:12]
    #print(UMI)
    if gene != previous_gene:
        previous_gene=gene
        genedict[gene]=[]
        genedict[gene].append(name)
        genedict[gene].append(sequence)
        genedict[gene].append(UMI)
    else:
        genedict[gene].append(name)
        genedict[gene].append(sequence)
        genedict[gene].append(UMI) #creates genedict that has gene_id keys storing the names, seqs, and UMIs of associated reads (in that order)

#print(genedict)
for key,value in genedict.items(): #key is referring to gene id
    length=len(list(filter(None, value)))    
    #print(length)    #length is how many entries in value list of genedict (e.g. 3, 6,9...where 3 means that there are 1 read for this gene_id, 6 means 2 reads for this gene_id)
    if length < 6: #if there is only one read for this gene in the cell...
        finalfasta.write('>%s\n%s\n' % (genedict[key][0], genedict[key][1]))

    elif length >= 6: #if gene has two or more reads associated with it, check for matching UMIs between them
        group={}
        y=0
        id=-1
        for i in range(2,length,3): #creates little readname subgroups with matched UMIs; 
                                    #iterate to fetch each UMI (key[i]) of each read 
            for j in range(i+3,length,3):   #iterate to fetch the next UMI (key[i+3])
                id+=1
                group[id]=[] 
                #print(genedict[key])
                if editdistance.eval(genedict[key][i],genedict[key][j]) <=1:
                    #print(genedict[key][i])
                    condition='no' 
                    while genedict[key][i-2] and genedict[key][j-2] not in group[y]: #as groupdict grows, check each previous entry for a match
                        condition='no'
                        if genedict[key][i-2] in group[y]:
                            group[y].append(genedict[key][i-2])
                            group[y].append(genedict[key][i-1])
                            group[y].append(genedict[key][j-2])
                            group[y].append(genedict[key][j-1])
                            condition='yes'
                            break #if match is found, append the values and break loop
                            
                        elif y>=id: #once the length of the dictionary has been reached, break the loop
                            break

                        y += 1 #loop through the dictionary until either of the above conditions are met

                        if condition == 'no':
                            group[id]=[genedict[key][i-2], genedict[key][i-1],genedict[key][j-2],genedict[key][j-1]]
                                    #if no matches found after scanning all previous entries, add new entry with the values
        #print(group)
        for entry in group: #clean up group dictionary and consolidate entries; 
            #print(entry)    #entry =0, 2,2 
            #print(len(group)) #this prints the # of dict.items(); len(group)=3
            for z in range(entry+1,len(group),1):
                print(z)
                for a in range(0,len(group[entry]),1):
                    if group[entry][a] in group[z]:
                        group[z]=[]
        #print(group)
        
        for entry in group:
            
            if group[entry]:
                refgroup={}
                leng=len(group[entry])
                for i in range(0,leng,2):
                    name=group[entry][i]
                    seq=group[entry][i+1]
                    refgroup[name]=seq #creates readname:seq dictionary for all matched reads
                print(refgroup)
                readname,readseq=make_consensus(refgroup,path='/mithril/Data/Nanopore/projects/visium/210309_r2c2_sample6_test/alice_c3poa_outs/c3poa_postprocessing/demuxed/temporary', input_path='/mithril/Data/Nanopore/projects/visium/210309_r2c2_sample6_test/alice_c3poa_outs/c3poa_postprocessing/demuxed', cell='56', barcode='TAGTTAAGATAGGATA') #call make_consensus function--defined below
                finalfasta.write('%s\n%s\n' % (readname, readseq)) #writes consensus read to out file
        matchlist=[]
        for entry in group:
            if group[entry]:
                for c in range(0,len(group[entry]),1):
                    matchlist.append(group[entry][c])
        #print(matchlist)
        for b in range(0,length,3): #writes reads under the gene_id that had NO UMI matches to final cell fasta
            if genedict[key][b] not in matchlist:
                finalfasta.write('>%s\n%s\n' % (genedict[key][b], genedict[key][b+1]))
finalfasta.close()


